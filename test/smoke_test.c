// generated by codex

#include "../include/bitcask.h"

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>

typedef bool (*test_fn_t)(void);

typedef struct test_case
{
    const char *name;
    test_fn_t fn;
} test_case_t;

static double elapsed_seconds(const struct timespec *start, const struct timespec *end)
{
    time_t sec = end->tv_sec - start->tv_sec;
    long nsec = end->tv_nsec - start->tv_nsec;
    return (double)sec + (double)nsec / 1000000000.0;
}

static bool rm_rf(const char *path)
{
    char cmd[512];
    int n = snprintf(cmd, sizeof(cmd), "rm -rf %s", path);
    if (n < 0 || (size_t)n >= sizeof(cmd))
    {
        return false;
    }
    return system(cmd) == 0;
}

static bool path_exists(const char *path)
{
    struct stat sb;
    return stat(path, &sb) == 0;
}

static bool write_byte_at(const char *path, long offset, uint8_t byte)
{
    FILE *fp = fopen(path, "r+b");
    if (fp == NULL)
    {
        return false;
    }
    if (fseek(fp, offset, SEEK_SET) != 0)
    {
        fclose(fp);
        return false;
    }
    if (fputc((int)byte, fp) == EOF)
    {
        fclose(fp);
        return false;
    }
    if (fclose(fp) != 0)
    {
        return false;
    }
    return true;
}

static bool test_basic_put_get_delete(void)
{
    const char *dir = "test/test-basic";
    if (!rm_rf(dir))
    {
        return false;
    }

    bitcask_handle_t db;
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        return false;
    }

    if (!bitcask_put(&db, (const uint8_t *)"alpha", 5, (const uint8_t *)"one", 3))
    {
        bitcask_close(&db);
        return false;
    }
    if (!bitcask_put(&db, (const uint8_t *)"beta", 4, (const uint8_t *)"two", 3))
    {
        bitcask_close(&db);
        return false;
    }

    uint8_t *out = NULL;
    size_t out_size = 0;
    bool ok = bitcask_get(&db, (const uint8_t *)"alpha", 5, &out, &out_size);
    if (!ok || out_size != 3 || memcmp(out, "one", 3) != 0)
    {
        free(out);
        bitcask_close(&db);
        return false;
    }
    free(out);

    if (!bitcask_delete(&db, (const uint8_t *)"alpha", 5))
    {
        bitcask_close(&db);
        return false;
    }

    out = NULL;
    out_size = 0;
    if (bitcask_get(&db, (const uint8_t *)"alpha", 5, &out, &out_size))
    {
        free(out);
        bitcask_close(&db);
        return false;
    }

    bitcask_close(&db);
    return true;
}

static bool test_reopen_persistence(void)
{
    const char *dir = "test/test-reopen";
    if (!rm_rf(dir))
    {
        return false;
    }

    bitcask_handle_t db;
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        return false;
    }
    if (!bitcask_put(&db, (const uint8_t *)"persist", 7, (const uint8_t *)"hello-world", 11))
    {
        bitcask_close(&db);
        return false;
    }
    bitcask_close(&db);

    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        return false;
    }

    uint8_t *out = NULL;
    size_t out_size = 0;
    bool ok = bitcask_get(&db, (const uint8_t *)"persist", 7, &out, &out_size);
    bool valid = ok && out_size == 11 && memcmp(out, "hello-world", 11) == 0;
    free(out);
    bitcask_close(&db);
    return valid;
}

static bool test_read_only_semantics(void)
{
    const char *dir = "test/test-readonly-existing";
    const char *missing = "test/test-readonly-missing";
    if (!rm_rf(dir) || !rm_rf(missing))
    {
        return false;
    }

    bitcask_handle_t db;
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        return false;
    }
    if (!bitcask_put(&db, (const uint8_t *)"k", 1, (const uint8_t *)"v", 1))
    {
        bitcask_close(&db);
        return false;
    }
    bitcask_close(&db);

    if (!bitcask_open(&db, dir, BITCASK_READ_ONLY))
    {
        return false;
    }

    uint8_t *out = NULL;
    size_t out_size = 0;
    bool get_ok = bitcask_get(&db, (const uint8_t *)"k", 1, &out, &out_size);
    free(out);
    if (!get_ok || out_size != 1)
    {
        bitcask_close(&db);
        return false;
    }

    if (bitcask_put(&db, (const uint8_t *)"x", 1, (const uint8_t *)"y", 1))
    {
        bitcask_close(&db);
        return false;
    }
    bitcask_close(&db);

    if (bitcask_open(&db, missing, BITCASK_READ_ONLY))
    {
        bitcask_close(&db);
        return false;
    }
    if (path_exists(missing))
    {
        return false;
    }
    return true;
}

static bool test_crc_rejected_on_get(void)
{
    const char *dir = "test/test-crc-get";
    const char *datafile = "test/test-crc-get/01.data";
    if (!rm_rf(dir))
    {
        return false;
    }

    bitcask_handle_t db;
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        return false;
    }
    if (!bitcask_put(&db, (const uint8_t *)"k", 1, (const uint8_t *)"hello", 5))
    {
        bitcask_close(&db);
        return false;
    }

    if (!write_byte_at(datafile, 29L, (uint8_t)'X'))
    {
        bitcask_close(&db);
        return false;
    }

    uint8_t *out = NULL;
    size_t out_size = 0;
    bool ok = bitcask_get(&db, (const uint8_t *)"k", 1, &out, &out_size);
    free(out);
    bitcask_close(&db);
    return !ok;
}

static bool test_crc_rejected_on_reopen(void)
{
    const char *dir = "test/test-crc-open";
    const char *datafile = "test/test-crc-open/01.data";
    if (!rm_rf(dir))
    {
        return false;
    }

    bitcask_handle_t db;
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        return false;
    }
    if (!bitcask_put(&db, (const uint8_t *)"k", 1, (const uint8_t *)"hello", 5))
    {
        bitcask_close(&db);
        return false;
    }
    bitcask_close(&db);

    if (!write_byte_at(datafile, 29L, (uint8_t)'X'))
    {
        return false;
    }

    if (bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        bitcask_close(&db);
        return false;
    }
    return true;
}

static bool test_benchmark(void)
{
    const char *dir = "test/test-benchmark";
    const size_t writes = 512000;
    const size_t lookups = 256000;
    const size_t value_size = 1024; // 1 KiB
    uint8_t *value = malloc(value_size);

    if (!rm_rf(dir))
    {
        return false;
    }
    if (value == NULL)
    {
        return false;
    }

    bitcask_handle_t db;
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        free(value);
        return false;
    }

    struct timespec t0;
    struct timespec t1;
    clock_gettime(CLOCK_MONOTONIC, &t0);
    for (size_t i = 0; i < writes; i++)
    {
        char key[32];
        int n = snprintf(key, sizeof(key), "bench-%08zu", i);
        if (n < 0 || (size_t)n >= sizeof(key))
        {
            bitcask_close(&db);
            free(value);
            return false;
        }

        for (size_t j = 0; j < value_size; j++)
        {
            value[j] = (uint8_t)((i + j) & 0xFFu);
        }

        if (!bitcask_put(&db, (const uint8_t *)key, (size_t)n, value, value_size))
        {
            bitcask_close(&db);
            free(value);
            return false;
        }
    }
    if (!bitcask_sync(&db))
    {
        bitcask_close(&db);
        free(value);
        return false;
    }
    clock_gettime(CLOCK_MONOTONIC, &t1);

    double write_sec = elapsed_seconds(&t0, &t1);
    double write_ops = (double)writes / write_sec;
    double write_mib = ((double)writes * (double)value_size) / (1024.0 * 1024.0);
    size_t total_bytes = writes * value_size;
    size_t expected_files = (total_bytes + (size_t)MAX_FILE_SIZE - 1) / (size_t)MAX_FILE_SIZE;
    printf("[bench] writes=%zu value_size=%zu bytes time=%.3fs ops/s=%.0f throughput=%.2f MiB/s\n",
           writes, value_size, write_sec, write_ops, write_mib / write_sec);
    printf("[bench] wrote=%.2f MiB expected_datafiles=%zu (MAX_FILE_SIZE=%d)\n",
           write_mib, expected_files, MAX_FILE_SIZE);

    bitcask_close(&db);
    if (!bitcask_open(&db, dir, BITCASK_READ_WRITE))
    {
        free(value);
        return false;
    }

    clock_gettime(CLOCK_MONOTONIC, &t0);
    for (size_t i = 0; i < lookups; i++)
    {
        size_t idx = (i * 7919u) % writes;
        char key[32];
        int n = snprintf(key, sizeof(key), "bench-%08zu", idx);
        if (n < 0 || (size_t)n >= sizeof(key))
        {
            bitcask_close(&db);
            free(value);
            return false;
        }

        uint8_t *out = NULL;
        size_t out_size = 0;
        if (!bitcask_get(&db, (const uint8_t *)key, (size_t)n, &out, &out_size))
        {
            free(out);
            bitcask_close(&db);
            free(value);
            return false;
        }
        if (out_size != value_size)
        {
            free(out);
            bitcask_close(&db);
            free(value);
            return false;
        }
        if (out[0] != (uint8_t)(idx & 0xFFu) || out[value_size - 1] != (uint8_t)((idx + value_size - 1) & 0xFFu))
        {
            free(out);
            bitcask_close(&db);
            free(value);
            return false;
        }
        free(out);
    }
    clock_gettime(CLOCK_MONOTONIC, &t1);

    double read_sec = elapsed_seconds(&t0, &t1);
    double read_ops = (double)lookups / read_sec;
    printf("[bench] lookups=%zu time=%.3fs ops/s=%.0f\n", lookups, read_sec, read_ops);

    bitcask_close(&db);
    free(value);
    return true;
}

int main(void)
{
    test_case_t tests[] = {
        {.name = "basic_put_get_delete", .fn = test_basic_put_get_delete},
        {.name = "reopen_persistence", .fn = test_reopen_persistence},
        {.name = "read_only_semantics", .fn = test_read_only_semantics},
        {.name = "crc_rejected_on_get", .fn = test_crc_rejected_on_get},
        {.name = "crc_rejected_on_reopen", .fn = test_crc_rejected_on_reopen},
        {.name = "benchmark", .fn = test_benchmark},
    };

    size_t passed = 0;
    size_t total = sizeof(tests) / sizeof(tests[0]);

    for (size_t i = 0; i < total; i++)
    {
        bool ok = tests[i].fn();
        printf("[%s] %s\n", ok ? "PASS" : "FAIL", tests[i].name);
        if (ok)
        {
            passed++;
        }
    }

    printf("summary: %zu/%zu passed\n", passed, total);
    return passed == total ? 0 : 1;
}
